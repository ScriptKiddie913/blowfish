
import { cacheAPIResponse, getCachedData } from '@/lib/database';

export interface OpenSourceMalwareResult {
  id: string;
  name: string;
  type: 'package' | 'repository' | 'file';
  ecosystem?: 'npm' | 'pypi' | 'rubygems' | 'other';
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  confidence: number;
  firstSeen: string;
  lastSeen: string;
  author?: string;
  references: string[];
  tags: string[];
}

class OpenSourceMalwareService {
  private readonly baseUrl = 'https://opensourcemalware.com/api/v1'; // Assuming v1 based on common practices
  private apiKey: string | null = null;

  constructor() {
    this.apiKey = localStorage.getItem('osm_api_key');
  }

  private getHeaders(): HeadersInit {
    const headers: HeadersInit = {
      'Accept': 'application/json',
      'Content-Type': 'application/json',
    };
    
    // Refresh key from storage in case it changed
    const currentKey = localStorage.getItem('osm_api_key');
    if (currentKey) {
      headers['Authorization'] = `Bearer ${currentKey}`;
    }
    
    return headers;
  }

  async searchMalware(query: string): Promise<OpenSourceMalwareResult[]> {
    if (!query) return [];
    
    // Refresh key
    this.apiKey = localStorage.getItem('osm_api_key');
    if (!this.apiKey) {
      console.warn('[OpenSourceMalware] No API key configured');
      return [];
    }

    const cacheKey = `osm:search:${query}`;
    const cached = await getCachedData(cacheKey);
    if (cached) return cached;

    try {
      console.log(`[OpenSourceMalware] Searching for: ${query}`);
      
      // Note: Endpoint structure is assumed. Adjust based on actual API docs.
      // Likely endpoints: /search, /packages/search, /query
      const response = await fetch(`${this.baseUrl}/search?q=${encodeURIComponent(query)}`, {
        method: 'GET',
        headers: this.getHeaders()
      });

      if (!response.ok) {
        if (response.status === 401 || response.status === 403) {
            console.error('[OpenSourceMalware] Invalid API key');
            // Optionally notify user via UI/toast if possible, or just return empty
        }
        throw new Error(`API failed: ${response.status}`);
      }

      const data = await response.json();
      
      // Transform response to unified format
      // Assuming response structure: { data: [...] } or { results: [...] } or just [...]
      const items = data.results || data.data || (Array.isArray(data) ? data : []);
      
      const results: OpenSourceMalwareResult[] = items.map((item: any) => ({
        id: item.id || `osm-${Math.random().toString(36).substr(2, 9)}`,
        name: item.name || item.package_name || 'Unknown Threat',
        type: item.type || 'package',
        ecosystem: item.ecosystem || 'unknown',
        description: item.description || 'No description provided',
        severity: item.severity || 'medium',
        confidence: item.confidence || 80,
        firstSeen: item.created_at || new Date().toISOString(),
        lastSeen: item.updated_at || new Date().toISOString(),
        author: item.author || 'Unknown',
        references: item.references || [],
        tags: item.tags || ['malware', 'opensource']
      }));

      await cacheAPIResponse(cacheKey, results, 1000 * 60 * 60); // 1 hour cache
      return results;

    } catch (error) {
      console.error('[OpenSourceMalware] Search failed:', error);
      return [];
    }
  }
}

export const openSourceMalwareService = new OpenSourceMalwareService();
